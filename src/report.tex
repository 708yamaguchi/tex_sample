%% 課題内容：
%% 「知能制御論」の講義を通して，自身が関連すると思うテーマで，
%% かつ興味のあるテーマを１つ設定し，モデル化や制御系設計法
%% の特徴，手法の概略，設計時の条件・注意点，具体的な適用例
%% などを数式や図を用いながら，10ページ以内（用紙サイズ A4，
%% フォント 10.5pt，一行45文字程度，一頁40行程度）でまとめよ．
%% 図を用いても良いが，大きくなり過ぎないように注意すること．
%% なお，テーマの設定に困ったら，講義で述べた事例から１つ選ん
%% でも良い．

\section{手法の概略・適用例}

知能制御論の第2回の授業でロボットアームの軌道計画の話を聞き、興味がわきました。
ロボットアームが障害物を回避するというアプリケーションに関して有名な手法を調べ、自分でもPythonプログラムを実装して実験してみました。

授業で紹介されていた軌道最適化手法はサンプリングベースのものだったので、CHOMP
\footnote{CHOMP \url{https://ieeexplore.ieee.org/abstract/document/5152817}}
やTrajOpt
\footnote{TrajOpt \url{https://journals.sagepub.com/doi/abs/10.1177/0278364914528132}}
など最適化ベースの手法に取り組みました。

本レポートで試した手法の概略は、符号付き距離関数（SDF）による衝突判定と逐次二次計画法（SQP）による軌道最適化で、CHOMPとTrajOptを組み合わせたものになっています。

\begin{table}[htbp]
  \centering
  \begin{tabular}{c||c|c}
    手法 & 物体との衝突判定 & 最適化手法                         \\ \hline
    CHPOP      & 符号付き距離関数（SDF） & 最急降下法            \\
    TrajOpt    & 凸包（Convex hull）     & 逐次二次計画法（SQP） \\
    本レポート & 符号付き距離関数（SDF） & 逐次二次計画法（SQP） \\
  \end{tabular}
  \caption{軌道最適化の元にした手法と本レポートの比較}
  \label{table:compare}
\end{table}

\section{モデル化・制御系設計}
大きさのないリンクとジョイントがつながったロボットアームを使って衝突回避軌道を計算います。さらにその際、時系列のロボットアーム軌道を計算できるようにすることが目標です。

そのため、以下のようなモデル化を行い最適化を行いました。

\begin{itemize}
  \item 制約条件
  \begin{itemize}
    \item ロボットアームの各リンク端点が円形障害物とぶつからない
    \item 最適化計算で出力された軌道の最初のロボットアームのエンドエフェクタの位置と、現在のロボットアームのエンドエフェクタの位置の距離が、一定値以下
    \item 最適化計算で出力された軌道の最後のロボットアームのエンドエフェクタの位置と、移動先のロボットアームのエンドエフェクタの位置の距離が、一定値以下
  \end{itemize}

  \item 目的関数
    \begin{itemize}
      \item 各時間的ステップにおけるロボットアームの関節角度列がなるべく離れるようにする
    \end{itemize}
\end{itemize}

以上の条件を最適化の枠組みで表現すると以下のようになります。

\begin{equation*}
  \begin{aligned}
    & \underset{x}{\text{minimize}}
    & & f(x_{1:T}) \\
    & \text{subject to}
    & & \|g_{l}(x_t) - pos_{obs}\|^2 - d_{obs} \geq 0, \; l = 1, \ldots, L, \; obs = 1, \ldots, N, \; t = 1, \ldots, T \\
    & \text{}
    & & \|g_L(x_0) - pos_{start}\|^2 - err_{start} \leq 0 \\
    & \text{}
    & & \|g_L(x_T) - pos_{goal}\|^2 - err_{goal} \leq 0 \\
    & \text{where}
    & & x_t\text{は、ロボットアームの関節角度ベクトル。時刻}t=1\text{から}t=T\text{まで存在する。} \\
    & \text{}
    & & l\text{は、}L\text{リンクあるロボットアームのジョイント番号。} \\
    & \text{}
    & & obs\text{は、}N\text{個ある円形障害物の番号。} \\
    & \text{}
    & & f(x_{1:T})\text{は、隣り合う補間点におけるロボットアームの関節角度列の差分の二乗和} \\
    & \text{}
    & & \text{　　　すなわち、}f(x_{1:T}) = \sum_{t=1}^{T-1} \|x_{t+1} - x_t\|^2 \\
    & \text{}
    & & pos_{obs}\text{は、}obs\text{番目の障害物の位置} \\
    & \text{}
    & & d_{obs}\text{は、}obs\text{番目の円形障害物の半径} \\
    & \text{}
    & & g_{l}(x)\text{は、関節角度}x{において、ルートから数えて}l\text{番目のリンク終端位置}\\
    & \text{}
    & & \text{　　　ルートから数えて}k\text{番目のリンク長、関節角度をそれぞれ}link_k\text{、}x_k\text{とすると、}\\
    & \text{}
    & & \text{　　　二次元空間内では、}g_l(x) = \left( \begin{array}{cc} \sum_{k=1}^{l} link_k\sin{x_k} & \sum_{k=1}^{l} link_k\cos{x_k} \end{array} \right)\\
    & \text{}
    & & pos_{start}\text{および}pos_{goal}\text{は、軌道の始点および終点におけるロボットアームの手先目標位置} \\
    & \text{}
    & & err_{start}\text{および}err_{goal}\text{は、軌道の始点および終点におけるロボットアーム手先位置の許容誤差}
  \end{aligned}
\end{equation*}

ここで、$f(x)$は==B

プログラムでの計算を高速化するため、目的関数$f(x)$に関してはヤコビアンを解析的に計算してscipyのminimize関数
\footnote{scipyを使ったSLSQP計算 \url{https://docs.scipy.org/doc/scipy-1.2.1/reference/optimize.minimize-slsqp.html?highlight=minimize}}
に渡します。
残りの制約関数に関してはヤコビアン計算を行っていないため、scipy.minimize関数側で数値微分を行っています。

プログラムで計算する際は計算の高速化を行うため、時系列関節角度$x_t$を縦に並べ一つのベクトルにしてから上記の式を行列で表現し、scipyのminimize関数


%% \begin{equation*}
%% g_{j,obs}(x_t) - d_{obs}=\left( \begin{array}{cc}
%% a & b \\
%% c & d
%% \end{array} \right)
%% B=\left( \begin{array}{cc}
%% a & b \\
%% c & d
%% \end{array} \right)
%% C=\left( \begin{array}{cc}
%% a & b \\
%% c & d
%% \end{array} \right)
%% \end{equation*}


\section{設計時の条件や注意点}
\begin{itemize}
  \item プログラミングを簡略化するのと計算量を抑えるため、三次元空間ではなく二次元平面内における衝突判定を計算ています。
  \item ジョイントにおける衝突判定しかしておらず、リンクの衝突判定はしていないです。なので、リンクにはぶつかる可能性があります。
  \item 障害物のSDFを簡単に計算するため、障害物は形状は円形のみとしています。
  \item 最適化の初期解は、ロボットアームの初期姿勢を補間点数分だけ並べたベクトルになっています。
\end{itemize}
